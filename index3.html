<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="js/3.5/spine-core.js"></script>
<script src="js/3.5/spine-widget.js"></script>
<script src="js/spine-skeleton-binary.js"></script>

<title>Insert title here</title>

<script>
	var animations;
	var animationqueue;
	var togglenum = true;

	$(document).ready(function() {

		var xhr = new XMLHttpRequest();
		xhr.open('GET', "spineassets/character/char_010_chen_nian_2/front/char_010_chen_nian_2.skel", true);
		xhr.responseType = 'arraybuffer';
		var array;

		xhr.onloadend = function(e) {
			if (xhr.status != 404) {
				buffer = xhr.response;
				array = new Uint8Array(buffer);
				skelBin = new SkeletonBinary();
				var jsonskel;
				skelBin.data = array;
				skelBin.initJson();
				jsonskel = JSON.stringify(skelBin.json);
				var parsedskeljson = JSON.parse(jsonskel);
				console.log(JSON.parse(jsonskel));

				var spineX = parseFloat($("#player-container").width()) / 2;
				var spineY = parseFloat($("#player-container").height()) / 2 - 200;
				new spine.SpineWidget("player-container", {
					jsonContent : jsonskel,
					atlas : "spineassets/character/char_010_chen_nian_2/front/char_010_chen_nian_2.atlas",
					// animation : [ "Start", "Idle", "Attack" ],
					animation : "Default",
					backgroundColor : "#00000000",
					premultipliedAlpha : true,
					fitToCanvas : false,
					loop : true,
					x : spineX,
					y : spineY,
					scale : 1,
					success : function(widget) {
						var animIndex = 0;

						animations = widget.skeleton.data.animations;
						CreateAnimation(widget, [ "Start", "Idle", "Attack" ], true);

						// widget.canvas.onclick = function () {
						$(widget.canvas).click(function() {
							if (togglenum) {
								clearInterval(animationqueue);
								widget.state.clearTracks();
								togglenum = false;
							} else {
								CreateAnimation(widget, [ "Start", "Idle", "Attack" ], true);
								togglenum = true;
							}
						});

						// widget.canvas.onclick = function() {
						// animIndex++;
						// let animations = widget.skeleton.data.animations;
						// if (animIndex >= animations.length)
						// animIndex = 0;
						// widget.setAnimation(animations[animIndex].name);
						// }
					},
					error : function(obj) {
						console.log(obj);
					}
				});
			} else {
				$("#loading-spine").text("Load Failed");
			}
		};
		xhr.send()
	});

	function CreateAnimation(chibiwidget, animArray, endloop = false, skipStart = false, isendstop = false) {
		if (Array.isArray(animArray) && animArray.length > 1) {
			var delay = 0;
			var animNum = 0;
			if (animationqueue != undefined) {
				clearInterval(animationqueue);
			}
			var curranimplay = Array.isArray(animArray[0]) ? animArray[0][0] : animArray[0];
			if (chibiwidget.loaded) {
				chibiwidget.setAnimation(curranimplay);
			}
			chibiwidget.state.clearTracks();
			var curranimations = chibiwidget.skeleton.data.animations;
			animArray.forEach(element => {
				var curranim = element;
				var animTimes = 1;
				var isloop = animNum == animArray.length - 1;
				if (Array.isArray(element)) {
					curranim = element[0];
					animTimes = element[1];
					isloop = true;
				}
				if (animNum == 0) {
					chibiwidget.state.setAnimation(0, curranim, Array.isArray(animArray[0]) && animArray[0].length > 1 ? true : false);
				} else if (animNum == animArray.length - 1) {
					chibiwidget.state.addAnimation(animNum, curranim, !isendstop, delay);
				} else {
					chibiwidget.state.addAnimation(animNum, curranim, isloop, delay);
				}
				delay += curranimations[GetAnimationIndex(curranimations, curranim)].duration * animTimes;
				animNum++;
			});
			if (endloop) {
				if (skipStart) {
					animArray.shift();
				}
				console.log(animArray);
				animationqueue = setInterval(function() {
					var delay = 0;
					var animNum = 0;
					var curranimplay = Array.isArray(animArray[0]) ? animArray[0][0] : animArray[0];
					if (chibiwidget.loaded) {
						chibiwidget.setAnimation(curranimplay);
					}
					chibiwidget.state.clearTracks();
					animArray.forEach(element => {
						var curranim = element;
						var animTimes = 1;
						var isloop = animNum == animArray.length - 1;
						if (Array.isArray(element)) {
							curranim = element[0];
							animTimes = element[1];
							isloop = true;
						}
						if (animNum == 0) {
							chibiwidget.state.setAnimation(0, curranim, Array.isArray(animArray[0]) && animArray[0].length > 1 ? true : false);
						} else {
							chibiwidget.state.addAnimation(animNum, curranim, isloop, delay);
						}
						delay += curranimations[GetAnimationIndex(curranimations, curranim)].duration * animTimes;
						animNum++;
						console.log(element);
					});
				}, delay * 1000 - 20);
			}
		} else {
			if (animationqueue != undefined) {
				clearInterval(animationqueue);
			}
			var curranimplay = Array.isArray(animArray[0]) ? animArray[0][0] : animArray;
			if (chibiwidget.loaded) {
				chibiwidget.setAnimation(curranimplay);
			}
			chibiwidget.state.clearTracks();
			chibiwidget.state.setAnimation(0, curranimplay, !isendstop);
		}
	}

	function GetAnimationIndex(anim, name){
		return anim.map(e => e.name).indexOf(name)
	}
</script>

</head>
<body>
  <div id="player-container" style="width: 640px; height: 480px;"></div>
</body>
</html>
